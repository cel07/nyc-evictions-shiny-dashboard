# This file generated by Quarto; do not edit by hand.
# shiny_mode: core

from __future__ import annotations

from pathlib import Path
from shiny import App, Inputs, Outputs, Session, ui




def server(input: Inputs, output: Outputs, session: Session) -> None:
    # --- Dashboard Setup ---

    import os
    import pandas as pd
    import json
    import matplotlib.pyplot as plt
    from shiny.express import render, ui

    # Paths relative to the quarto_dashboard/ folder
    PROJECT_ROOT = os.path.dirname(os.getcwd())  # go up one level to the project root

    DATA_CLEAN_DIR = os.path.join(PROJECT_ROOT, "data_clean")
    DATA_FINAL_DIR = os.path.join(PROJECT_ROOT, "data_final")

    # --- Load data ---

    # Clean dataset (full detailed records)
    evictions_clean_path = os.path.join(DATA_CLEAN_DIR, "evictions_clean.csv")
    evictions_clean = pd.read_csv(evictions_clean_path, parse_dates=["executed_date"])

    # Monthly aggregation
    evictions_by_month_path = os.path.join(DATA_FINAL_DIR, "evictions_by_month.csv")
    evictions_by_month = pd.read_csv(evictions_by_month_path)

    # Borough/year aggregation
    evictions_by_borough_path = os.path.join(DATA_FINAL_DIR, "evictions_by_borough.csv")
    evictions_by_borough = pd.read_csv(evictions_by_borough_path)

    # GeoJSON points
    geojson_path = os.path.join(DATA_FINAL_DIR, "evictions_points.geojson")
    with open(geojson_path, "r", encoding="utf-8") as f:
        evictions_points_geojson = json.load(f)

    # Quick confirmation (silent because echo: false)
    #len(evictions_clean), len(evictions_by_month), len(evictions_by_borough), len(evictions_points_geojson["features"])

    # ========================================================================

    # Total number of eviction records
    total_evictions = len(evictions_clean)

    # Time range
    date_min = evictions_clean["executed_date"].min()
    date_max = evictions_clean["executed_date"].max()

    # Number of boroughs represented
    num_boroughs = evictions_clean["borough"].nunique()

    # Residential vs Commercial share
    res_mask = evictions_clean["residential_commercial_ind"] == "Residential"
    res_share = res_mask.mean()
    comm_share = 1 - res_share



    # # Total number of eviction records
    # total_evictions = len(evictions_clean)

    # # Time range
    # date_min = evictions_clean["executed_date"].min()
    # date_max = evictions_clean["executed_date"].max()

    # # Number of boroughs represented
    # num_boroughs = evictions_clean["borough"].nunique()

    # # Residential vs Commercial share
    # res_mask = evictions_clean["residential_commercial_ind"] == "Residential"
    # res_share = res_mask.mean()
    # comm_share = 1 - res_share

    # # Build a small KPI table
    # kpi_df = pd.DataFrame({
    #     "Metric": [
    #         "Total evictions (records)",
    #         "Time range (executed_date)",
    #         "Number of boroughs",
    #         "Residential share",
    #         "Commercial share",
    #     ],
    #     "Value": [
    #         f"{total_evictions:,}",
    #         f"{date_min.date()} to {date_max.date()}",
    #         num_boroughs,
    #         f"{res_share*100:.1f}%",
    #         f"{comm_share*100:.1f}%",
    #     ],
    # })

    # kpi_df

    # ========================================================================

    dict(
      value   = f"{total_evictions:,}",
      caption = "Total executed eviction records in the dataset"
    )

    # ========================================================================

    dict(
        value   = f"{date_min.date()} → {date_max.date()}",
        caption = "Earliest to latest executed_date"
    )

    # ========================================================================

    dict(
        value   = f"{num_boroughs}",
        caption = "Unique boroughs in the dataset"
    )

    # ========================================================================

    dict(
        value   = f"{res_share * 100:.1f}%",
        caption = "Evictions classified as Residential"
    )

    # ========================================================================

    dict(
        value   = f"{comm_share * 100:.1f}%",
        caption = "Evictions classified as Commercial"
    )

    # ========================================================================

    from shiny.express import input, render, ui
    import matplotlib.pyplot as plt

    # assume evictions_by_month already has a 'year' column and 'total_evictions'
    evictions_by_month["year_month_date"] = pd.to_datetime(evictions_by_month["year_month"])

    min_year = int(evictions_by_month["year"].min())
    max_year = int(evictions_by_month["year"].max())

    # --- UI control: Year range slider (this is NOT a dropdown, it's a slider) ---
    ui.input_slider(
        "year_range",
        "Year range:",
        min=min_year,
        max=max_year,
        value=(min_year, max_year),  # default = all years
        step=1,
    )

    # --- Reactive monthly line chart ---
    @render.plot
    def monthly_evictions_plot():
        start_year, end_year = input.year_range()

        df = (
            evictions_by_month[
                (evictions_by_month["year"] >= start_year)
                & (evictions_by_month["year"] <= end_year)
            ]
            .sort_values("year_month_date")
        )

        fig, ax = plt.subplots()
        ax.plot(df["year_month_date"], df["total_evictions"])
        ax.set_title("Monthly Evictions Executed by NYC Marshals")
        ax.set_xlabel("Month")
        ax.set_ylabel("Total Evictions")
        fig.autofmt_xdate()
        return fig



    # import plotly.express as px
    # import pandas as pd

    # # Pick the year you want to visualize
    # target_year = 2025  # <--- change this to whatever year you want

    # # Ensure year_month is datetime
    # evictions_by_month["year_month_date"] = pd.to_datetime(evictions_by_month["year_month"])

    # # Filter the dataset for the selected year
    # df_year = evictions_by_month[
    #     evictions_by_month["year_month_date"].dt.year == target_year
    # ]

    # # Create the chart
    # fig_monthly = px.line(
    #     df_year.sort_values("year_month_date"),
    #     x="year_month_date",
    #     y="total_evictions",
    #     title=f"Monthly Evictions Executed by NYC Marshals – {target_year}",
    #     labels={
    #         "year_month_date": "Month",
    #         "total_evictions": "Total Evictions"
    #     }
    # )

    # fig_monthly


    # import plotly.express as px

    # # Ensure year_month is a proper datetime for the x-axis
    # evictions_by_month["year_month_date"] = pd.to_datetime(evictions_by_month["year_month"])

    # fig_monthly = px.line(
    #     evictions_by_month.sort_values("year_month_date"),
    #     x="year_month_date",
    #     y="total_evictions",
    #     title="Monthly Evictions Executed by NYC Marshals",
    #     labels={
    #         "year_month_date": "Month",
    #         "total_evictions": "Total Evictions"
    #     }
    # )

    # fig_monthly


    # import plotly.graph_objects as go
    # import plotly.express as px

    # # Make a copy with a proper datetime column
    # evm = evictions_by_month.copy()
    # evm["year_month_date"] = pd.to_datetime(evm["year_month"])

    # years = sorted(evm["year"].unique())
    # default_view = "All years"

    # fig_monthly = go.Figure()

    # # 1) Trace for all years combined
    # evm_all = evm.sort_values("year_month_date")
    # fig_monthly.add_trace(
    #     go.Scatter(
    #         x=evm_all["year_month_date"],
    #         y=evm_all["total_evictions"],
    #         mode="lines",
    #         name="All years",
    #         visible=True,  # default visible
    #     )
    # )

    # # 2) One trace per year, initially hidden
    # for y in years:
    #     evm_y = evm[evm["year"] == y].sort_values("year_month_date")
    #     fig_monthly.add_trace(
    #         go.Scatter(
    #             x=evm_y["year_month_date"],
    #             y=evm_y["total_evictions"],
    #             mode="lines",
    #             name=str(y),
    #             visible=False,
    #         )
    #     )

    # # Build dropdown buttons
    # buttons = []

    # # Button for "All years"
    # visible_all = [True] + [False] * len(years)
    # buttons.append(
    #     dict(
    #         label=default_view,
    #         method="update",
    #         args=[
    #             {"visible": visible_all},
    #             {"title": "Monthly Evictions – All Years"},
    #         ],
    #     )
    # )

    # # Buttons for each year
    # for i, y in enumerate(years):
    #     visible = [False] * (len(years) + 1)
    #     visible[i + 1] = True  # turn on only this year's trace
    #     buttons.append(
    #         dict(
    #             label=str(y),
    #             method="update",
    #             args=[
    #                 {"visible": visible},
    #                 {"title": f"Monthly Evictions – {y}"},
    #             ],
    #         )
    #     )

    # fig_monthly.update_layout(
    #     title="Monthly Evictions – All Years",
    #     xaxis_title="Month",
    #     yaxis_title="Total Evictions",
    #     updatemenus=[
    #         dict(
    #             buttons=buttons,
    #             direction="down",
    #             showactive=True,
    #             x=1.02,
    #             xanchor="left",
    #             y=1,
    #             yanchor="top",
    #         )
    #     ],
    # )

    # fig_monthly

    # ========================================================================

    import plotly.express as px

    fig_borough = px.bar(
        evictions_by_borough,
        x="year",
        y="total_evictions",
        color="borough",
        barmode="group",
        title="Evictions by Borough and Year",
        labels={
            "year": "Year",
            "total_evictions": "Total Evictions",
            "borough": "Borough"
        }
    )

    fig_borough

    # ========================================================================

    # Select key columns for display
    table_columns = [
        "executed_date",
        "year",
        "borough",
        "eviction_address",
        "eviction_apt_num",
        "eviction_zip",
        "nta",
        "residential_commercial_ind",
        "ejectment_standardized",
        "eviction_possession",
        "marshal_first_name",
        "marshal_last_name",
    ]

    evictions_table = (
        evictions_clean[table_columns]
        .sort_values("executed_date", ascending=False)
        .reset_index(drop=True)
    )

    # Show only the first 1000 rows to keep the HTML light
    evictions_table.head(1000)

    # ========================================================================



    return None


_static_assets = ["index_files","index_files\\libs\\quarto-html\\tippy.css","index_files\\libs\\quarto-html\\quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css","index_files\\libs\\quarto-html\\quarto-syntax-highlighting-dark-bc185b5c5bdbcb35c2eb49d8a876ef70.css","index_files\\libs\\bootstrap\\bootstrap-icons.css","index_files\\libs\\bootstrap\\bootstrap-e68d4c56e0754488b54b1adf2459d850.min.css","index_files\\libs\\bootstrap\\bootstrap-dark-e68d4c56e0754488b54b1adf2459d850.min.css","index_files\\libs\\clipboard\\clipboard.min.js","index_files\\libs\\quarto-html\\quarto.js","index_files\\libs\\quarto-html\\tabsets\\tabsets.js","index_files\\libs\\quarto-html\\popper.min.js","index_files\\libs\\quarto-html\\tippy.umd.min.js","index_files\\libs\\quarto-html\\anchor.min.js","index_files\\libs\\bootstrap\\bootstrap.min.js","index_files\\libs\\quarto-dashboard\\quarto-dashboard.js","index_files\\libs\\quarto-dashboard\\stickythead.js","index_files\\libs\\quarto-dashboard\\web-components.js","index_files\\libs\\quarto-dashboard\\components.js"]
_static_assets = {"/" + sa: Path(__file__).parent / sa for sa in _static_assets}

app = App(
    Path(__file__).parent / "index.html",
    server,
    static_assets=_static_assets,
)
